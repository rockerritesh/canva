<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Fluid Dynamics Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
            color: #fff;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            padding: 20px;
            background-color: rgba(30, 30, 30, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #controls.hidden {
            transform: translateX(120%);
            opacity: 0;
            pointer-events: none;
        }

        #toggle-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: rgba(30, 30, 30, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            backdrop-filter: blur(10px);
        }

        h1 {
            margin-top: 0;
            font-size: 1.2rem;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            color: #4CAF50;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #ccc;
        }

        .slider-container {
            display: flex;
            align-items: center;
        }

        input[type="range"] {
            flex-grow: 1;
            margin-right: 10px;
            accent-color: #4CAF50;
        }

        span.value {
            display: inline-block;
            width: 50px;
            text-align: right;
            font-family: monospace;
            color: #4CAF50;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            flex: 1;
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #45a049;
        }

        button#reset {
            background-color: #f44336;
        }

        button#reset:hover {
            background-color: #d32f2f;
        }

        select {
            width: 100%;
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 4px;
        }

        option {
            background-color: #333;
        }

        .stats {
            margin-top: 15px;
            font-size: 0.8rem;
            color: #888;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 10px;
        }
    </style>
</head>

<body>
    <button id="toggle-controls">⚙️</button>

    <div id="controls">
        <h1>Fluid Dynamics</h1>

        <div class="control-group">
            <label for="resolution">Grid Resolution (N):</label>
            <select id="resolution">
                <option value="64">64 (Low)</option>
                <option value="128" selected>128 (Medium)</option>
                <option value="256">256 (High)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="viscosity">Viscosity:</label>
            <div class="slider-container">
                <input type="range" id="viscosity" min="0" max="0.1" step="0.0001" value="0.0001">
                <span id="viscosity-value" class="value">0.0001</span>
            </div>
        </div>

        <div class="control-group">
            <label for="diffusion">Diffusion:</label>
            <div class="slider-container">
                <input type="range" id="diffusion" min="0" max="0.1" step="0.0001" value="0.0001">
                <span id="diffusion-value" class="value">0.0001</span>
            </div>
        </div>

        <div class="control-group">
            <label for="iterations">Solver Iterations:</label>
            <div class="slider-container">
                <input type="range" id="iterations" min="1" max="50" step="1" value="16">
                <span id="iterations-value" class="value">16</span>
            </div>
        </div>

        <div class="control-group">
            <label for="display-mode">Display Mode:</label>
            <select id="display-mode">
                <option value="density">Density + Velocity</option>
                <option value="velocity">Velocity Magnitude</option>
                <option value="pressure">Pressure (Approx)</option>
            </select>
        </div>

        <div class="button-group">
            <button id="reset">Reset</button>
            <button id="toggle">Pause</button>
        </div>

        <div class="stats">
            FPS: <span id="fps">0</span>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="fluidCanvas"></canvas>
    </div>

    <script>
        // Setup canvas
        const canvas = document.getElementById('fluidCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency

        // Simulation parameters
        let N = 128; // Grid size
        let dt = 0.1; // Time step
        let diff = 0.0001; // Diffusion
        let visc = 0.0001; // Viscosity
        let iter = 16; // Solver iterations
        let running = true;
        let displayMode = 'density';

        // Arrays (using Float32Array for performance)
        let u, v, u_prev, v_prev, dens, dens_prev;

        // Mouse interaction
        let mouseX = 0, mouseY = 0;
        let mouseDown = false;
        let lastMouseX = 0, lastMouseY = 0;

        // Performance monitoring
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        // Resize handling
        let canvasScaleX = 1;
        let canvasScaleY = 1;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Calculate scale to map mouse coordinates to grid coordinates
            // We keep the simulation grid square (N x N) but stretch it to fill the screen
            canvasScaleX = N / canvas.width;
            canvasScaleY = N / canvas.height;
        }

        function initializeFluidField() {
            const size = N * N;
            u = new Float32Array(size);
            v = new Float32Array(size);
            u_prev = new Float32Array(size);
            v_prev = new Float32Array(size);
            dens = new Float32Array(size);
            dens_prev = new Float32Array(size);
        }

        // Helper: Get 1D index from 2D coordinates
        function IX(x, y) {
            return x + y * N;
        }

        // Boundary conditions
        function setBoundary(b, x) {
            for (let i = 1; i < N - 1; i++) {
                x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
                x[IX(N - 1, i)] = b === 1 ? -x[IX(N - 2, i)] : x[IX(N - 2, i)];
                x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
                x[IX(i, N - 1)] = b === 2 ? -x[IX(i, N - 2)] : x[IX(i, N - 2)];
            }

            x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
            x[IX(0, N - 1)] = 0.5 * (x[IX(1, N - 1)] + x[IX(0, N - 2)]);
            x[IX(N - 1, 0)] = 0.5 * (x[IX(N - 2, 0)] + x[IX(N - 1, 1)]);
            x[IX(N - 1, N - 1)] = 0.5 * (x[IX(N - 2, N - 1)] + x[IX(N - 1, N - 2)]);
        }

        // Linear solver (Gauss-Seidel)
        function linearSolve(b, x, x0, a, c) {
            const cRecip = 1.0 / c;
            for (let k = 0; k < iter; k++) {
                for (let j = 1; j < N - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        x[IX(i, j)] = (x0[IX(i, j)] +
                            a * (x[IX(i + 1, j)] +
                                x[IX(i - 1, j)] +
                                x[IX(i, j + 1)] +
                                x[IX(i, j - 1)])) * cRecip;
                    }
                }
                setBoundary(b, x);
            }
        }

        // Diffusion
        function diffuse(b, x, x0, diff, dt) {
            const a = dt * diff * (N - 2) * (N - 2);
            linearSolve(b, x, x0, a, 1 + 4 * a);
        }

        // Advection
        function advect(b, d, d0, u, v, dt) {
            let i0, j0, i1, j1;
            let x, y, s0, t0, s1, t1;

            const dtx = dt * (N - 2);
            const dty = dt * (N - 2);

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    x = i - dtx * u[IX(i, j)];
                    y = j - dty * v[IX(i, j)];

                    if (x < 0.5) x = 0.5;
                    if (x > N - 1.5) x = N - 1.5;
                    i0 = Math.floor(x);
                    i1 = i0 + 1;

                    if (y < 0.5) y = 0.5;
                    if (y > N - 1.5) y = N - 1.5;
                    j0 = Math.floor(y);
                    j1 = j0 + 1;

                    s1 = x - i0;
                    s0 = 1 - s1;
                    t1 = y - j0;
                    t0 = 1 - t1;

                    d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                        s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
                }
            }
            setBoundary(b, d);
        }

        // Projection (Mass Conservation)
        function project(u, v, p, div) {
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    div[IX(i, j)] = -0.5 * (
                        u[IX(i + 1, j)] -
                        u[IX(i - 1, j)] +
                        v[IX(i, j + 1)] -
                        v[IX(i, j - 1)]
                    ) / N;
                    p[IX(i, j)] = 0;
                }
            }

            setBoundary(0, div);
            setBoundary(0, p);
            linearSolve(0, p, div, 1, 4);

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    u[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) * N;
                    v[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) * N;
                }
            }

            setBoundary(1, u);
            setBoundary(2, v);
        }

        // Steps
        function densityStep() {
            diffuse(0, dens_prev, dens, diff, dt);
            advect(0, dens, dens_prev, u, v, dt);
        }

        function velocityStep() {
            diffuse(1, u_prev, u, visc, dt);
            diffuse(2, v_prev, v, visc, dt);
            project(u_prev, v_prev, u, v);
            advect(1, u, u_prev, u_prev, v_prev, dt);
            advect(2, v, v_prev, u_prev, v_prev, dt);
            project(u, v, u_prev, v_prev);
        }

        // Rendering
        function drawFluid() {
            // Create a temporary canvas to draw the grid, then scale it up
            // This is much faster than drawing pixel-by-pixel to the full screen canvas
            // However, for this demo, we'll stick to direct pixel manipulation but scale the context

            // Better approach for performance and look:
            // Draw to an offscreen canvas of size NxN, then draw that scaled up to the main canvas

            if (!window.offscreenCanvas || window.offscreenCanvas.width !== N) {
                window.offscreenCanvas = document.createElement('canvas');
                window.offscreenCanvas.width = N;
                window.offscreenCanvas.height = N;
                window.offscreenCtx = window.offscreenCanvas.getContext('2d');
                window.offscreenData = window.offscreenCtx.createImageData(N, N);
            }

            const data = window.offscreenData.data;

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = IX(i, j);
                    const pixelIdx = idx * 4;

                    let r, g, b;

                    if (displayMode === 'density') {
                        const d = dens[idx];
                        const u_val = u[idx];
                        const v_val = v[idx];
                        // Simple coloring: Density = brightness, Velocity = hue/tint
                        r = Math.min(255, d * 255 + Math.abs(u_val) * 500);
                        g = Math.min(255, d * 255 + Math.abs(v_val) * 500);
                        b = Math.min(255, d * 255 + Math.sqrt(u_val * u_val + v_val * v_val) * 500);
                    } else if (displayMode === 'velocity') {
                        const u_val = u[idx];
                        const v_val = v[idx];
                        const speed = Math.sqrt(u_val * u_val + v_val * v_val);
                        r = Math.min(255, Math.abs(u_val) * 1000);
                        g = Math.min(255, speed * 1000);
                        b = Math.min(255, Math.abs(v_val) * 1000);
                    } else {
                        // Fallback
                        const d = dens[idx];
                        r = g = b = Math.min(255, d * 255);
                    }

                    data[pixelIdx] = r;
                    data[pixelIdx + 1] = g;
                    data[pixelIdx + 2] = b;
                    data[pixelIdx + 3] = 255; // Opaque
                }
            }

            window.offscreenCtx.putImageData(window.offscreenData, 0, 0);

            // Draw scaled up to main canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.imageSmoothingEnabled = true; // Smooth the pixels
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(window.offscreenCanvas, 0, 0, canvas.width, canvas.height);
        }

        // Main Loop
        function animate(time) {
            if (running) {
                velocityStep();
                densityStep();
                drawFluid();
            }

            // FPS Calculation
            frameCount++;
            if (time - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = time;
            }

            requestAnimationFrame(animate);
        }

        // Initialization
        window.addEventListener('load', () => {
            resizeCanvas();
            initializeFluidField();
            animate(0);
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
            // Optional: re-init if you want to change N dynamically based on screen size, 
            // but usually we keep N fixed and just scale.
        });

        // Input Handling
        function handleInput(x, y, isDown) {
            // Map screen coordinates to grid coordinates
            const gridX = x * canvasScaleX;
            const gridY = y * canvasScaleY;

            if (isDown) {
                const i = Math.floor(gridX);
                const j = Math.floor(gridY);

                if (i >= 1 && i <= N - 2 && j >= 1 && j <= N - 2) {
                    // Add density
                    dens[IX(i, j)] += 100; // More density per frame

                    // Add velocity
                    const du = (gridX - lastMouseX) * 2; // Scale force
                    const dv = (gridY - lastMouseY) * 2;

                    u[IX(i, j)] += du;
                    v[IX(i, j)] += dv;
                }
            }

            lastMouseX = gridX;
            lastMouseY = gridY;
        }

        // Mouse
        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            const rect = canvas.getBoundingClientRect();
            lastMouseX = (e.clientX - rect.left) * canvasScaleX;
            lastMouseY = (e.clientY - rect.top) * canvasScaleY;
            handleInput(e.clientX - rect.left, e.clientY - rect.top, true);
        });

        canvas.addEventListener('mouseup', () => mouseDown = false);

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            handleInput(e.clientX - rect.left, e.clientY - rect.top, mouseDown);
        });

        // Touch
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mouseDown = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            lastMouseX = (touch.clientX - rect.left) * canvasScaleX;
            lastMouseY = (touch.clientY - rect.top) * canvasScaleY;
            handleInput(touch.clientX - rect.left, touch.clientY - rect.top, true);
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            mouseDown = false;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            handleInput(touch.clientX - rect.left, touch.clientY - rect.top, mouseDown);
        }, { passive: false });

        // UI Controls Logic
        const controlsPanel = document.getElementById('controls');
        const toggleBtn = document.getElementById('toggle-controls');

        toggleBtn.addEventListener('click', () => {
            controlsPanel.classList.toggle('hidden');
        });

        document.getElementById('viscosity').addEventListener('input', (e) => {
            visc = parseFloat(e.target.value);
            document.getElementById('viscosity-value').textContent = visc.toFixed(4);
        });

        document.getElementById('diffusion').addEventListener('input', (e) => {
            diff = parseFloat(e.target.value);
            document.getElementById('diffusion-value').textContent = diff.toFixed(4);
        });

        document.getElementById('iterations').addEventListener('input', (e) => {
            iter = parseInt(e.target.value);
            document.getElementById('iterations-value').textContent = iter;
        });

        document.getElementById('resolution').addEventListener('change', (e) => {
            N = parseInt(e.target.value);
            resizeCanvas(); // Update scale
            initializeFluidField(); // Reset grid
        });

        document.getElementById('display-mode').addEventListener('change', (e) => {
            displayMode = e.target.value;
        });

        document.getElementById('reset').addEventListener('click', initializeFluidField);

        document.getElementById('toggle').addEventListener('click', (e) => {
            running = !running;
            e.target.textContent = running ? 'Pause' : 'Resume';
        });

    </script>
</body>

</html>